<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Python工程师常用面试题——MySQL篇 | 何仕鹏的个人博客 | healthy,weathy,freedom,lucky,happy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="MySQL">
    <meta name="description" content="MySQL部分为什么MySQL使用B+树实现索引？看下索引的备选数据结构：顺序数组，哈希表，二叉搜索树，B树，B+树。  首先顺序数组。  顺序数组做查找操作很方便，使用二分查找，时间效率可以达到logN，但是如果做更新和删除操作，都需要移动大量元素，成本比较大。所以顺序数组更适合用于查询的领域，适合存储一些改动较小的静态存储引擎。  哈希表  哈希表的结构示意图如下：   哈希索引虽然查找效率可">
<meta property="og:type" content="article">
<meta property="og:title" content="Python工程师常用面试题——MySQL篇">
<meta property="og:url" content="http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/index.html">
<meta property="og:site_name" content="何仕鹏的个人博客">
<meta property="og:description" content="MySQL部分为什么MySQL使用B+树实现索引？看下索引的备选数据结构：顺序数组，哈希表，二叉搜索树，B树，B+树。  首先顺序数组。  顺序数组做查找操作很方便，使用二分查找，时间效率可以达到logN，但是如果做更新和删除操作，都需要移动大量元素，成本比较大。所以顺序数组更适合用于查询的领域，适合存储一些改动较小的静态存储引擎。  哈希表  哈希表的结构示意图如下：   哈希索引虽然查找效率可">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071756484.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071856059.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071954875.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306072220057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306091755542.png">
<meta property="article:published_time" content="2022-06-07T08:00:55.000Z">
<meta property="article:modified_time" content="2023-06-14T02:10:02.894Z">
<meta property="article:author" content="拾光的碎羽">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071756484.png">
    
        <link rel="alternate" type="application/atom+xml" title="何仕鹏的个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092054351.png">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092044923.jpeg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092042366.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">拾光的碎羽</h5>
          <a href="mailto:1615433864@qq.com" title="1615433864@qq.com" class="mail">1615433864@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom.xml" target="_blank" >
                <i class="icon icon-lg icon-feed"></i>
                RSS
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Python工程师常用面试题——MySQL篇</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Python工程师常用面试题——MySQL篇</h1>
        <h5 class="subtitle">
            
                <time datetime="2022-06-07T08:00:55.000Z" itemprop="datePublished" class="page-time">
  2022-06-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MySQL%E9%83%A8%E5%88%86"><span class="post-toc-number">1.</span> <span class="post-toc-text">MySQL部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E4%BD%BF%E7%94%A8B-%E6%A0%91%E5%AE%9E%E7%8E%B0%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">为什么MySQL使用B+树实现索引？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">索引的分类？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8BMySQL%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F%EF%BC%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%89"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">什么情况下MySQL索引会失效？（使用索引需要注意的地方）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">索引的优缺点？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">什么时候不使用索引</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">索引创建的原则？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B0%88%E8%B0%88%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">谈谈前缀索引？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">如何创建索引？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">什么是索引下推？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%EF%BC%9F"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">MySQL为什么建议使用自增主键？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B0%88%E8%B0%88Change-Buffer%EF%BC%9F"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">谈谈Change Buffer？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">普通索引与唯一索引如何选择？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B0%88%E8%B0%88MySQL%E4%B8%BA%E5%95%A5%E4%BC%9A%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">谈谈MySQL为啥会选错索引？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Explain%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">Explain命令查看哪些属性？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#varchar%E4%B8%8Echar%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">varchar与char的区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MySQL%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">MySQL执行查询的过程？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="post-toc-number">1.17.</span> <span class="post-toc-text">什么是数据库事务？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MySQL%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="post-toc-number">1.18.</span> <span class="post-toc-text">MySQL的四种隔离级别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="post-toc-number">1.19.</span> <span class="post-toc-text">事务的实现原理</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Python工程师常用面试题一"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Python工程师常用面试题——MySQL篇</h1>
        <div class="post-meta">
            <time class="post-time" title="2022-06-07 16:00:55" datetime="2022-06-07T08:00:55.000Z"  itemprop="datePublished">2022-06-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h3 id="MySQL部分"><a href="#MySQL部分" class="headerlink" title="MySQL部分"></a>MySQL部分</h3><h4 id="为什么MySQL使用B-树实现索引？"><a href="#为什么MySQL使用B-树实现索引？" class="headerlink" title="为什么MySQL使用B+树实现索引？"></a>为什么MySQL使用B+树实现索引？</h4><p>看下索引的备选数据结构：顺序数组，哈希表，二叉搜索树，B树，B+树。</p>
<ol>
<li>首先顺序数组。</li>
</ol>
<p>顺序数组做查找操作很方便，使用二分查找，时间效率可以达到<code>logN</code>，但是如果做更新和删除操作，都需要移动大量元素，成本比较大。所以顺序数组更适合用于查询的领域，适合存储一些改动较小的静态存储引擎。</p>
<ol start="2">
<li>哈希表</li>
</ol>
<p>哈希表的结构示意图如下：</p>
<img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071756484.png" alt="img" style="zoom:50%;" />

<p>哈希索引虽然查找效率可以达到常数级别，但是仍然存在一些缺点：</p>
<ul>
<li>Hash索引只能满足相等，不等，IN查询，不能够做范围查询。因为有序的键值经过Hash算法之后可能变为不连续的了，这个时候就无法用索引完成范围查询。</li>
<li>Hash索引无法利用索引排序。因为索引数据并不是按照索引值顺序存储的。</li>
<li>联合索引中，Hash索引不能利用部分索引键查询。Hash索引在计算Hash值的时候，是联合索引合并后一起计算的Hash值，所以通过前面一个或几个索引键进行查询的时候，Hash索引也无法被利用。</li>
<li>Hash索引在任何时候都不能避免表扫描。哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li>
<li>在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</li>
</ul>
<ol start="3">
<li>二叉搜索树</li>
</ol>
<p>二叉搜索树的结构如下：</p>
<img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071856059.webp" alt="img" style="zoom:67%;" />

<p>二叉搜索树的每个节点都只存储一个键值，并且左子树所有节点的值都要小于根节点的值，右子树所有节点的值都要大于根节点的值。当二叉搜索树的所有非叶子节点的左右子树的节点数目均保持差不多时，搜索性能接近二分查找。并且相对于有序数组，二叉搜索树插入与删除操作不需要移动大量数据。</p>
<p>但是数据库存储大多不使用二叉树，因为数据量较大时，树高会过高，这样子会增加磁盘IO的开销。</p>
<ol start="4">
<li>B树</li>
</ol>
<p>B树的结构如下：</p>
<img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306071954875.png" alt="img" style="zoom:30%;" />

<p>B树的特点是：</p>
<ul>
<li>所有键值分布在整颗树中。</li>
<li>搜索有可能在非叶子结点结束，在关键字全集内做一次查找，性能接近二分查找。</li>
<li>每个节点最多拥有m个子树，最多有m-1个键值。</li>
<li>根节点至少有2个子树。</li>
<li>分支节点至少拥有m&#x2F;2颗子树。</li>
<li>所有叶子节点都在同一层、每个节点最多可以有m-1个key，并且以升序排列。</li>
</ul>
<p>B树相比于二叉搜索树，性能都可以接近二分查找，但是B树是多叉树，可以降低树的高度。但是B树也有缺点：</p>
<ul>
<li>每个节点都有key，同时也包含data，而每个页存储空间是有限的，如果data比较大的话会导致每个节点存储的key数量变小。</li>
<li>当存储的数据量很大的时候会导致深度较大，增大查询时磁盘io次数，进而影响查询性能。</li>
</ul>
<ol start="5">
<li>B+树</li>
</ol>
<p>B+树的结构如下：</p>
<img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306072220057.png" alt="img" style="zoom: 50%;" />

<p>B+树在B树的基础上做了一些优化：</p>
<ul>
<li>B+树每个节点可以包含更多的节点。</li>
<li>非叶子节点存储key，叶子节点存储key和数据。</li>
<li>叶子节点两两指针相互连接。</li>
</ul>
<p>B+树相对于B树更加适合用于索引的原因：</p>
<ul>
<li>降低了树的高度，减少了磁盘IO次数，将数据范围变为多个区间，区间越多，数据检索越快。</li>
<li>支持区间查询。</li>
</ul>
<p>综上，B+树更加适用于用于创建索引。</p>
<h4 id="索引的分类？"><a href="#索引的分类？" class="headerlink" title="索引的分类？"></a>索引的分类？</h4><ol>
<li>按照数据结构分</li>
</ol>
<ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>Full-text索引。</li>
</ul>
<ol start="2">
<li>按照物理存储分</li>
</ol>
<ul>
<li><p>聚簇索引</p>
<ul>
<li><p>每个叶子节点存储了一行完整的表数据，叶子节点间按id列递增连接，可以方便地进行顺序检索。</p>
</li>
<li><p><strong>以InnoDB为引擎的表要求必须有聚簇索引</strong>，默认在主键字段上建立聚簇索引，在没有主键字段的情况下，表的第一个非空的唯一索引将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个隐式的自增id列，并在此列上建立聚簇索引。</p>
</li>
<li><p>数据页只能按照一颗B+树进行排序，因此<strong>每张表只能拥有一个聚集索引</strong>。</p>
</li>
<li><p><strong>以MyISAM为引擎的表不存在聚簇索引</strong>。</p>
</li>
</ul>
</li>
<li><p>二级索引</p>
<ul>
<li>在<strong>聚集索引之上创建的索引叫做二级索引&#x2F;辅助索引</strong>。</li>
<li>当通过二级索引查询到聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据（回表查询）。</li>
<li><strong>通过二级索引查询时，回表不是必须的过程</strong>，当<strong>SELECT的所有字段在单个二级索引中都能够找到</strong>时，就不需要回表，MySQL称此时的二级索引为<strong>覆盖索引</strong>或触发了<strong>索引覆盖</strong>。（<strong>会问到回表过程是否是必须的</strong>）</li>
</ul>
</li>
</ul>
<ol start="3">
<li>按功能特性分</li>
</ol>
<ul>
<li>主键索引：一张数据表只能有一个主键索引，<strong>索引列值不允许有空值</strong>。（<strong>会问到主键与唯一索引的区别</strong>）</li>
<li>唯一索引：一张表可以有多个唯一索引，<strong>索引列值允许为空，列值中出现多个空值不会发生重复冲突</strong>。</li>
<li>普通索引</li>
<li>前缀索引<ul>
<li>前缀索引可以建立在类型为char、varchar、binary、varbinary的列上，可以大大减少索引占用的存储空间。</li>
<li>对于INNODB存储引擎而言，默认前缀长度最大能支持767字节；而在开启<strong>innodb_large_prefix</strong>属性值的情况下，最大能支持3072字节。</li>
<li>对于MyISAM存储引擎而言，前缀长度限制为1000字节。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>按照索引字段个数分</li>
</ol>
<ul>
<li>单列索引</li>
<li>联合索引</li>
</ul>
<h4 id="什么情况下MySQL索引会失效？（使用索引需要注意的地方）"><a href="#什么情况下MySQL索引会失效？（使用索引需要注意的地方）" class="headerlink" title="什么情况下MySQL索引会失效？（使用索引需要注意的地方）"></a>什么情况下MySQL索引会失效？（使用索引需要注意的地方）</h4><ol>
<li>联合索引不满足最左匹配原则</li>
</ol>
<p>最左匹配原则：在联合索引中，最左侧的字段优先匹配（最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符）。因此，在创建联合索引时，where子句中使用最频繁的字段放在联合索引的最左侧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 索引为 id_no-username-age</span><br><span class="line">-- 索引有效</span><br><span class="line">explain select * from t_user where id_no = &#x27;1002&#x27;;</span><br><span class="line">explain select * from t_user where id_no = &#x27;1002&#x27; and username = &#x27;Tom2&#x27;;</span><br><span class="line">explain select * from t_user where id_no = &#x27;1002&#x27; and age = 12;</span><br><span class="line">explain select * from t_user where id_no like &quot;1001%&quot;;</span><br><span class="line">-- 索引失效</span><br><span class="line">explain select * from t_user where username = &#x27;Tom2&#x27; and age = 12;</span><br><span class="line">explain select * from t_user where age = 12;</span><br><span class="line">explain select * from t_user where username = &#x27;Tom2&#x27;;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>使用了select *</li>
</ol>
<p>禁止使用select * 语句可能会带来的附带好处就是：某些情况下可以走覆盖索引。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select id_no, username, age from t_user where username = &#x27;Tom2&#x27;;</span><br><span class="line">explain select id_no, username, age from t_user where age = 12;</span><br></pre></td></tr></table></figure>

<p>不需要做回表查询。</p>
<ol start="3">
<li>索引列参与运算</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id + 1 = 2 ;</span><br></pre></td></tr></table></figure>

<p>上述SQL语句为例，数据库需要全表扫描出所有的id字段值，然后对其计算，计算之后再与参数值进行比较。</p>
<p>优化：先在内存中进行计算好预期的值，或者在SQL语句条件的右侧进行参数值的计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 内存计算，得知要查询的id为1</span><br><span class="line">explain select * from t_user where id = 1 ;</span><br><span class="line">-- 参数侧计算</span><br><span class="line">explain select * from t_user where id = 2 - 1 ;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>索引列作为函数的参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where SUBSTR(id_no,1,3) = &#x27;100&#x27;;</span><br></pre></td></tr></table></figure>

<p>数据库要先进行全表扫描，获得数据之后再进行截取、计算，导致索引索引失效。</p>
<ol start="5">
<li>错误的使用like</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id_no like &#x27;%00%&#x27;;</span><br></pre></td></tr></table></figure>

<p>占位符出现在首部，导致无法走索引。引本身就相当于目录，从左到右逐个排序。而条件的左侧使用了占位符，导致无法按照正常的目录进行匹配，导致失效。</p>
<ol start="6">
<li>类型隐式转换</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id_no = 1002;</span><br></pre></td></tr></table></figure>

<p>类型不一致，导致全表扫描。</p>
<p><strong>注意一个特殊情况：如果字段类型为int类型，而查询条件添加了单引号或双引号，则Mysql会参数转化为int类型，虽然使用了单引号或双引号。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id = &#x27;2&#x27;;</span><br></pre></td></tr></table></figure>



<ol start="7">
<li>使用OR操作</li>
</ol>
<ul>
<li>使用or操作的左右两边的字段都必须要有索引，否则会全表扫描，索引失效。</li>
<li>or两边为范围查询时，索引会失效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id = 2 or username = &#x27;Tom2&#x27;;</span><br><span class="line">explain select * from t_user where id  &gt; 1 or id  &lt; 80;</span><br></pre></td></tr></table></figure>



<ol start="8">
<li>两列做比较</li>
</ol>
<p>带索引的两列如果做比较，也会导致索引失效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id &gt; age;</span><br></pre></td></tr></table></figure>



<ol start="9">
<li>不等于比较可能导致索引失效。</li>
</ol>
<p>使用不等条件查询时，当查询结果集占比比较小时，会走索引，占比比较大时不会走索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 有效</span><br><span class="line">explain select * from t_user where id != 2;</span><br><span class="line">-- 失效</span><br><span class="line">explain select * from t_user where create_time != &#x27;2022-02-26 09:04:23&#x27;;</span><br></pre></td></tr></table></figure>



<ol start="10">
<li>使用<code>is not null</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id_no is not null;</span><br></pre></td></tr></table></figure>

<p>查询条件使用<code>is null</code>时正常走索引，使用<code>is not null</code>时，不走索引。</p>
<ol start="11">
<li>使用<code>not in</code>和<code>not exists</code></li>
</ol>
<p>范围查询中有2个特例：<code>not in</code>和<code>not exists</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 有效</span><br><span class="line">explain select * from t_user where id not in (2,3);</span><br><span class="line">-- 失效</span><br><span class="line">explain select * from t_user where create_time not in (&#x27;2022-02-26 09:04:23&#x27;);</span><br><span class="line">explain select * from t_user u1 where not exists (select 1 from t_user u2 where u2.id  = 2 and u2.id = u1.id);</span><br></pre></td></tr></table></figure>

<p>如果是主键则走索引，如果是普通索引，则索引失效。</p>
<ol start="12">
<li>order by导致索引失效</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user order by id_no ;</span><br></pre></td></tr></table></figure>

<p>对全表数据进行排序处理，导致索引失效。</p>
<p>使用<code>limit</code>索引依然失效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user order by id_no limit 60;</span><br></pre></td></tr></table></figure>

<p><strong>也看结果集占总数据的占比，如果占比比较大，索引不会失效</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 有效</span><br><span class="line">explain select * from t_user order by id_no limit 60;</span><br></pre></td></tr></table></figure>

<p><strong>对主键使用order by索引不会失效</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user order by id desc;</span><br></pre></td></tr></table></figure>



<ol start="13">
<li>参数不同导致索引失效</li>
</ol>
<p>DBMS发现全表扫描比走索引效率更高，因此就放弃了走索引。如上边的<code>order by limit</code>，不等于比较。</p>
<h4 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h4><ol>
<li>优点</li>
</ol>
<ul>
<li>建立索引的列可以保证行的唯一性，生成唯一的rowId。</li>
<li>建立索引可以有效缩短数据的检索时间。</li>
<li>建立索引可以加快表与表之间的连接。</li>
</ul>
<ol start="2">
<li>缺点</li>
</ol>
<ul>
<li>创建索引和维护索引需要时间成本和空间成本。</li>
<li>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长。</li>
</ul>
<h4 id="什么时候不使用索引"><a href="#什么时候不使用索引" class="headerlink" title="什么时候不使用索引"></a>什么时候不使用索引</h4><ul>
<li>经常增删改的列不要建立索引</li>
<li>有大量重复数据&#x2F;数据区分度低的列不要建立索引</li>
<li>表记录太少不要建立索引</li>
</ul>
<h4 id="索引创建的原则？"><a href="#索引创建的原则？" class="headerlink" title="索引创建的原则？"></a>索引创建的原则？</h4><ol>
<li>选择区分度高&#x2F;离散度高&#x2F;重复值少的字段创建索引。</li>
</ol>
<p>比如性别不适合做索引，手机号适合做索引。</p>
<ol start="2">
<li>只为用于搜索，排序，分组的列创建索引。</li>
<li>不要为联合索引的第一个索引列单独创建索引；建立联合索引时，一定要把最常用的列放在最左边。</li>
<li>对过长的字段，建立前缀索引。可以节省磁盘空间。</li>
<li>频繁更新的值，不要作为主键或者索引。索引会降低增删改的效率，频繁更新的值会导致性能问题。</li>
</ol>
<h4 id="谈谈前缀索引？"><a href="#谈谈前缀索引？" class="headerlink" title="谈谈前缀索引？"></a>谈谈前缀索引？</h4><ol>
<li>什么是前缀索引</li>
</ol>
<p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索引的方式叫做前缀索引。</p>
<ol start="2">
<li>前缀索引的优缺点</li>
</ol>
<p>优点：前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引值，从而提高了索引查询的速度。</p>
<p>缺点：不能在 order by 或者 group by 中触发前缀索引，也不能把它们用于覆盖索引。</p>
<ol start="3">
<li>什么情况下使用前缀索引</li>
</ol>
<p>当字符串本身可能比较长，而且前几个字符就开始不相同，适合使用前缀索引；相反情况下不适合使用前缀索引。</p>
<h4 id="如何创建索引？"><a href="#如何创建索引？" class="headerlink" title="如何创建索引？"></a>如何创建索引？</h4><ol>
<li>使用<code>create table</code>语句创建</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">    id INT auto_increment PRIMARY KEY,</span><br><span class="line">    first_name VARCHAR (16),</span><br><span class="line">    last_name VARCHAR (16),</span><br><span class="line">    id_card VARCHAR (18),</span><br><span class="line">    information text,</span><br><span class="line">    KEY name (first_name, last_name),</span><br><span class="line">    FULLTEXT KEY (information),</span><br><span class="line">    UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>使用<code>alter table</code>语句创建</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br><span class="line">ALTER TABLE table_name ADD UNIQUE INDEX index_name (column_list);</span><br><span class="line">ALTER TABLE table_name ADD PRIMARY KEY index_name (column_list);</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>使用<code>create index</code>语句创建</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure>



<h4 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h4><p>索引下推指的是可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from t_user where id_no = &#x27;1002&#x27; and age = 12;</span><br></pre></td></tr></table></figure>

<p>联合索引为<code>id_no-age</code>，如果没有索引下推，在B+树搜索的时候InnoDB并不会看age字段的值，只是按顺序把id_no为12的记录一条条取出来回表。引入索引下推之后，InnoDB 在 <code>id_no-age</code> 索引内部就判断了 age 是否等于 12，对于不等于 12 的记录，直接判断并跳过，这样有效的减少了回表的次数。</p>
<h4 id="MySQL为什么建议使用自增主键？"><a href="#MySQL为什么建议使用自增主键？" class="headerlink" title="MySQL为什么建议使用自增主键？"></a>MySQL为什么建议使用自增主键？</h4><p>使用自增id可以避免页分裂。mysql在底层是以数据页为单位来存储数据的，一个数据页大小默认为16k（这个大小可以自定义）。如果主键为自增id的话，mysql在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。如果主键是非自增 id，为了把数据放到合适的节点上(保证插入数据后依然维持B+树的特性)，可能会对已存在的节点造成分裂在组合的影响，分裂在组合就是不必要的性能消耗，而且当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上，这就造成了页分裂，移动数据的过程是会严重影响插入效率的。</p>
<h4 id="谈谈Change-Buffer？"><a href="#谈谈Change-Buffer？" class="headerlink" title="谈谈Change Buffer？"></a>谈谈Change Buffer？</h4><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。（change buffer好比黑板，磁盘上的数据页好比账本）</p>
<p><strong>change buffer也可以持久化到磁盘上</strong>。</p>
<p>将change buffer与原始页数据进行合并的操作称为merge。merge的时机：</p>
<ul>
<li>访问数据页。</li>
<li>系统有后台线程会定期 merge。</li>
<li>在数据库正常关闭的过程中。</li>
</ul>
<h4 id="普通索引与唯一索引如何选择？"><a href="#普通索引与唯一索引如何选择？" class="headerlink" title="普通索引与唯一索引如何选择？"></a>普通索引与唯一索引如何选择？</h4><p>通常情况下尽量使用普通索引。理由如下：</p>
<ol>
<li>查询过程</li>
</ol>
<p><strong>普通索引和唯一索引性能相差无几</strong>。对于唯一索引，在查找过程中，找到第一个满足条件的记录就会停止继续检索；对于普通索引，查找到第一个满足条件的记录之后，会继续查找直到碰到第一个不满足条件的。</p>
<p>InnoDB 的数据是按数据页为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。所以，对于普通索引无非是继续在内存中做一次指针寻找和计算。</p>
<ol start="2">
<li>更新过程</li>
</ol>
<p><strong>普通索引在更新时可以使用change buffer，唯一索引不使用change buffer，通常情况下前者更新效率更高</strong>。当要更新的数据页在内存，唯一索引相比于普通索引无非是多一次比较操作，性能相差无几；当要更新的数据页不在内存中时，唯一索引做更新时要判断记录是否存在时，需要把数据页读入内存，不会去使用change buffer；而普通索引做更新时不需要判断记录是否存在，直接把数据更新到change buffer，而不会把数据页读入到内存，降低了磁盘IO。</p>
<p><strong>写多读少使用 change buffer 可以加快执行速度，减少数据页磁盘IO。 但是，如果业务模型是写后立马会做查询，则会触发change buffer立即merge 到磁盘，这样的场景磁盘io次数不会减少，反而会增加change buffer的维护代价。</strong></p>
<h4 id="谈谈MySQL为啥会选错索引？"><a href="#谈谈MySQL为啥会选错索引？" class="headerlink" title="谈谈MySQL为啥会选错索引？"></a>谈谈MySQL为啥会选错索引？</h4><p>选择索引是优化器的工作。优化器是根据扫描行数，否使用临时表、是否排序等因素进行综合判断。在某些情况下优化器没有准确的判断出扫描行数，导致MySQL选错索引。</p>
<ol>
<li>mysql如何判断一个查询的扫描行数?</li>
</ol>
<p>通过索引的区分度即基数（一个索引上不同的值的个数）来估算记录数。</p>
<ol start="2">
<li>索引基数如何计算?</li>
</ol>
<p>InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。</p>
<ol start="3">
<li>可以重新统计索引信息的命令是什么?</li>
</ol>
<p><code>analyze table t</code>命令。</p>
<ol start="4">
<li>索引选择异常如何解决?</li>
</ol>
<ul>
<li>采用 force index 强行选择一个索引。MySQL 会根据词法解析的结果分析出可能可以使用的索引作为候选项，然后在候选列表中依次判断每个索引需要扫描多少行。如果 force index 指定的索引在候选索引列表中，就直接选择这个索引，不再评估其他索引的执行代价。</li>
<li>可以修改语句，引导 MySQL 使用我们期望的索引。</li>
<li>可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</li>
</ul>
<h4 id="Explain命令查看哪些属性？"><a href="#Explain命令查看哪些属性？" class="headerlink" title="Explain命令查看哪些属性？"></a>Explain命令查看哪些属性？</h4><ul>
<li><p><strong>select_type</strong>：查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</p>
<ul>
<li><code>SIMPLE</code>：查询中不包含子查询或者<code>UNION</code></li>
<li>查询中若包含任何复杂的子部分，最外层查询则被标记为：<code>PRIMARY</code></li>
<li>在<code>SELECT</code>或<code>WHERE</code>列表中包含了子查询，该子查询被标记为：<code>SUBQUERY</code></li>
</ul>
</li>
<li><p><strong>type</strong>：访问类型。</p>
<ul>
<li>ALL：全表扫描</li>
<li>index：扫描全部索引树</li>
<li>range：扫描部分索引，索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询。</li>
<li>ref：使用非唯一索引或非唯一索引前缀进行的查找</li>
<li>fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引。</li>
<li>eq_ref：查找唯一性索引，返回的数据至多一条。属于精确查找。</li>
<li>const：查找主键索引，返回的数据至多一条（0或者1条）。属于精确查找。</li>
<li>system：表中只有一行数据或者是空表，且只能用于myisam和memory表。</li>
</ul>
</li>
<li><p><strong>possible_keys</strong>：显示可能应用在这张表中的索引，一个或多个。</p>
</li>
<li><p><strong>key</strong>：优化器实际使用的索引，必然包含在possible_keys中，如果没有索引被选择，是NULL。</p>
</li>
<li><p><strong>key_len</strong>：使用到索引字段的长度。</p>
</li>
<li><p><strong>rows</strong>：MySQL根据表统计信息及索引选用情况，估算mysql查询过程中遍历的行数，不是准确值。</p>
</li>
</ul>
<h4 id="varchar与char的区别？"><a href="#varchar与char的区别？" class="headerlink" title="varchar与char的区别？"></a>varchar与char的区别？</h4><ul>
<li>char是一个定长字段，比如申请了<code>char(10)</code>的空间,那么无论实际存储多少内容，该字段都占用 10 个字符；而varchar是变长的，申请的只是最大长度，占用的空间为实际字符长度+1，最后一个字符存储使用了多长的空间。</li>
<li>检索效率上char的效率高于varchar，如果某个字段既可以使用char又可以使用varchar，应该尽量使用varchar，比如md5码。</li>
</ul>
<h4 id="MySQL执行查询的过程？"><a href="#MySQL执行查询的过程？" class="headerlink" title="MySQL执行查询的过程？"></a>MySQL执行查询的过程？</h4><p>mysql的逻辑架构图如下：</p>
<img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202306091755542.png" alt="img" style="zoom: 20%;" />

<ol>
<li>与MySQL连接器进行连接。客户端通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配。</li>
<li>查询缓存。MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句，如果缓存命中，直接返回查询结果。</li>
<li>SQL语法分析。若没命中，分析器对SQL语句进行词法分析，语法分析，检查SQL语法是否正确。</li>
<li>优化。优化器对SQL进行优化，比如使用哪个索引，多表关联的时候，决定各个表的连接顺序。</li>
<li>执行。执行器会判断对查询的表是否有执行查询的权限，如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</li>
</ol>
<h4 id="什么是数据库事务？"><a href="#什么是数据库事务？" class="headerlink" title="什么是数据库事务？"></a>什么是数据库事务？</h4><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。事务具备四个特点：</p>
<ul>
<li>原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</li>
<li>一致性。在事务开始之前和事务结束以后，数据库的完整性没有被破坏。</li>
<li>隔离性。一个事务的执行不能其它事务干扰，一个事务内部的操作及使用的数据对其它并发事务是隔离的。</li>
<li>持续性。指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。</li>
</ul>
<h4 id="MySQL的四种隔离级别？"><a href="#MySQL的四种隔离级别？" class="headerlink" title="MySQL的四种隔离级别？"></a>MySQL的四种隔离级别？</h4><ul>
<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li>串行化：当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>四种隔离级别：并行性能依次降低，安全性依次提高。</p>
<h4 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h4><ul>
<li>事务的原子性是通过 undo log 来实现的。</li>
<li>事务的持久性性是通过 redo log 来实现的。</li>
<li>事务的隔离性是通过 (读写锁+MVCC)来实现的。</li>
</ul>
<ol>
<li>原子性的实现</li>
</ol>
<ul>
<li>每条数据变更(insert&#x2F;update&#x2F;delete)操作都伴随一条undo log的生成，并且回滚日志必须先于数据持久化到磁盘上；</li>
<li>所谓的回滚就是根据回滚日志做逆向操作，比如delete的逆向操作为insert，insert的逆向操作为delete，update的逆向为update等。</li>
</ul>
<ol start="2">
<li>持久化的实现</li>
</ol>
<p>每提交一个事务必须先将该事务的所有日志写入到redo log文件进行持久化，数据库就可以通过重做日志来保证事务的持久性。</p>
<ol start="3">
<li>隔离性的实现</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2023-06-14T02:10:02.894Z" itemprop="dateUpdated">2023-06-14 10:10:02</time>
</span><br>


        
        关注微信公众号~~逆向一步步~~，第一时间获取更新文章的推送 <br/> 版权声明：本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！
        
    </div>
    
    <footer>
        <a href="http://example.com">
            <img src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092042366.jpg" alt="拾光的碎羽">
            拾光的碎羽
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&title=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&pic=https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092042366.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&title=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&source=专注于爬虫,机器学习,深度学习,算法,后端等领域的学习" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&via=http://example.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%8C/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Python工程师常用面试题——数据结构算法篇</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/AST%E8%A7%A3JS%E6%B7%B7%E6%B7%86%E4%B9%8B%E5%8E%BB%E6%8E%89%E6%9C%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">AST解JS混淆之去掉未被调用的函数</h4>
      </a>
    </div>
  
</nav>



    

















<section class="comments" id="comments">
    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>
        var id = location.pathname
        if (location.pathname.length > 50) {
          id = location.pathname.replace(/\/\d+\/\d+\/\d+\//, '').replace('/', '').substring(0, 50)
        }
        const gitalk = new Gitalk({
          clientID: 'eb07520a302f5438d2f9',
          clientSecret: 'dcd2e7c80f28c206cd938c3d2f4317bc45bc3adf',
          repo: 'lyy077.github.io',
          owner: 'lyy077',
          admin: ['lyy077'],
          id: id,      // Ensure uniqueness and length less than 50
          title: document.title.split('|')[0],
          distractionFreeMode: false  // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    </script>
</section>




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢宝贝~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205100208236.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205100208236.jpg" data-alipay="https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205100209914.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>拾光的碎羽 &copy; 2021 - 2023</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">鄂ICP备2022001140号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&title=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&pic=https://raw.githubusercontent.com/lyy077/blg-pic/main/pic/202205092042366.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&title=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&source=专注于爬虫,机器学习,深度学习,算法,后端等领域的学习" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Python工程师常用面试题——MySQL篇》 — 何仕鹏的个人博客&url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/&via=http://example.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://example.com/Python%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%B8%B8%E7%94%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD7klEQVR42u3aS07DQBAFQO5/aZBYIYHNe93jCKTyKnKcsae86PTn7S0+3j+Pr5+/Ht/Pf//V1TpX316dub/yfv1jBw4cOHDgCLZ6dSS3v/pVvo1kY/d3SV5M9LQ4cODAgeMQRxJc84dLoljybb5+G/Ivz+PAgQMHjhdy5NuYhcwcuk3/cODAgQPH3+TYJGObkJwXDXHgwIEDx9/haENgfst9+yp5zlkIx4EDBw4cT3DMBhr+1+fH5ztw4MCBA8c6dM3aUUmgjRKtOAUt9oUDBw4cONYc7dBA0lLKxxc2688aXVEAxoEDBw4cC468fHZ2JG4WSjetpmg8AgcOHDhwHOXIl2tHDdo12+ZTixgFWhw4cODAseDYDKXlSdTst22xb4WOAwcOHDgOcbTp0GbQoQ3bbYjdJJw4cODAgWPP0Qazluk+sOUcbSht0zkcOHDgwPE0R3t+Vi6cEbfjFJvd4cCBAweOliO5wRMluX1ba1PKrEflcODAgQNHOWOWN4pmA2ptsW8WUGeUPzwhDhw4cOBYcJwqyc3GCGabSYp9eVi9nO/AgQMHDhwjjjq9GbWXZsH4VAqXv04cOHDgwLHnSMLhrESYsOaBcN/uSkI+Dhw4cODYcxSTDqNC4abUmINuXkPRl8OBAwcOHAHHbHSgberkgTxP9tokMEoUceDAgQPHmmM2mnCqnDcbocj/NeTPvJrUwIEDBw4ccdspD8PJ7TdM+bbb9Ys8EgcOHDhwPNxbaUcKZiW/zfl2CAMHDhw4cOw58vGFpM0zW2HWuMpLk8UrxIEDBw4chzj2426zIYO8BZU8Yd7uqrtwOHDgwIGj7OC3oTRP4fJQl6d8eUI4DOQ4cODAgWPB0TZ42qGHNsGbgZ5KNXHgwIEDxymOfCBgPwbXrtYWHGevEAcOHDhwvIYjL+S17aU8FWxTvgMDDThw4MCB44HZsLODa23jZ88aJWxJlRQHDhw4cIw4TgWzNlWb3SvZ3uzAgQMHDhx7jnZjeWrUlu3yMLxpdw3TPxw4cODAEa+/KfC1gTPPktpiYrLOMIXDgQMHDhwjjjZwJuW//Jp9Apm3wX55Khw4cODAseZo06T92Fx+tCXFduXo3wcOHDhw4Cg5No2ZGd9sBGFWvszXwYEDBw4cpzg2YS/fdhLtN9z59cdCOA4cOHDguL1XHhRnJbl9Cyop9h0LtDhw4MCB4xBHkiZt2kV5stQOIszWv7weBw4cOHC8nKMdMkgSszwBa1drwzMOHDhw4HglxwxlP3Ywa1DNXjMOHDhw4DjFkd94k8gl355Cb9fBgQMHDhynONqBhnY+Ih96yB96VgrclCxx4MCBA0fA8QHWVuKVBvlsrwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js?v=1.7.2" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<!--<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>-->
<script async src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>






<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
